<!DOCTYPE html>
<html><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    <meta name="description" content="http://localhost:1313/">
    

    <meta property="og:site_name" content="d.kens">
    <meta property="og:title" content="d.kens">
    <meta property="og:description" content="">
    <meta property="og:type" content="website">
    <meta property="og:url" content="http://localhost:1313/blog/just-a-hobby/">
    <meta property="og:image" content="http://localhost:1313/">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="http://localhost:1313/blog/just-a-hobby/">
    <meta name="twitter:image" content="http://localhost:1313/">

    
    <link rel="stylesheet" type="text/css" href="http://localhost:1313/css/style.css">
    
    
    

    <link rel="stylesheet" href="https://use.typekit.net/jxt2fnp.css"> 
    <link rel="stylesheet" href="https://use.typekit.net/uwd7war.css"> 
    <link href="https://fonts.cdnfonts.com/css/cooper-hewitt" rel="stylesheet">
    
    
        <meta name="description" content="A personal blog">
    

    
        
            <link rel="shortcut icon" href="/favicon.png">
        
    

    
    
    
    
    <title>just a hobby | d.kens</title>
</head><body><div id="top-stripe"></div><div id="content">

    <div class="article-nav-outer">
        <div class="article-nav-inner">
            <a class="internal" hyphens="none" href="/blog">← back to blog</a>
        </div>
    </div>

<h2 class="article-title">Just a Hobby</h2>
<div id="doc">
    <div class="hanging-subtitle">
        
        
            <p>by [Dave Kensinger]</p>
                
        
            
                <p>16 June 2019</p>
            
        
    </div>
<p>(original article written in December 2016)</p>
<h2 id="the-start">The Start</h2>
<p>Programming. It’s my new hobby. Well, also <em>reading about</em> programming. Hacker News, Reddit, all kinds of blogs and other sites. Also computer science. Also a hobby. Algorithms, big O notation, functional versus imperative languages, searching, sorting, data structures, strong versus weak typed languages, operator overloading, etc. Ad infinitum. I think it’s fascinating. Not terribly fun sometimes, not easy to grasp most of the time. But still… it’s fascinating. And empowering.</p>
<p>I grew up at the start of the personal computer era. My neighbor worked at a local IBM facility and had an Apple II in his basement (was that disloyal?). Another one down the street built his own (I think a Heathkit H8?) My first computer was an IBM PC with an 8088 processor (yes, before the 8086, 286, 386, 486, pentium… etc.) with a green CRT monitor just like you’d imagine. It was an incredibly expensive toy for a kid to play with. I took it to college and never did much more than write papers and play with spreadsheets. Actually, I did my senior project on it… wrote my senior thesis and wrote some very basic programs in TrueBasic. I even used Lotus 1-2-3 and began using spreadsheets for some basic engineering work. Yes, I’m that old.</p>
<p>I never really learned to program though. I took one semester of Pascal… hated the whole process. Hated the waiting in line at the computer lab to sit in front of a terminal to debug a 150 line program. I recall we were to use 3D matrix transformations on basic images. Rotate, resize, translate. It never clicked with me and I didn’t have the patience for it. I never felt like I knew how to even approach the task. I just wrestled with syntax. And Pascal wasn’t forgiving. I wonder if things would have been different if Turbo-Pascal had come out just a few years earlier. What took us hours could have been done in seconds. Who knows?</p>
<p>That was 1986. Fast forward to 2014.</p>
<p>My first reaction to that temporal jump is: holy cow! Almost thirty years! What I hold in my hand does more than the entire computer lab at my university could do. I can actually write powerful code… in minutes!.. on my phone!.. It used to take me days to struggle with code that never even worked in the end. Sigh.</p>
<p>What changed? Everything.</p>
<h2 id="the-journey">The Journey</h2>
<p>After my first steps in high school and college, I spent many years in the world of Microsoft; starting with DOS 6.2 and progressing through windows 3, 3.1, 3.11, windows 95, 98, NT, 2000, then to windows ME and XP… I saw it all. I saw the MS Office suite take over and dominate the world. I always had some sort of PC in the house. Nothing too powerful. Always in the $3,000 range.</p>
<p>I remember my first modem was 300 baud. Then I was excited to upgrade to 14,400 baud. That was so I could connect to Compuserve and what was then a very exciting “internet”. No programming though.</p>
<p>Years later, I remember seeing the first browsers Gopher and Netscape Navigator. Even Internet Explorer. Those were interesting days. Still, no programming. One colleague of mine was pretty absorbed in his computer world and programmed some pretty cool things in Visual Basic. I was impressed. I was more of a power user of applications. Spreadsheets, slide shows and the like. Never real programming though.</p>
<p>Sometime around 2001 I switched over to the Mac. It was when they switched over to Mac OS X and I still have a powerPC laptop with both System 9.2 and 10.1 on it. Mac was new to me then so I thought the older system looked… older. The newer system was shiny but pretty slow. Not that I cared much though. I was tired of the never-ending reboot -&gt; reinstall program -&gt;reinstall windows -&gt; cycle of misery. Firewalls, antivirus programs, malware detectors… it was a lousy experience. But one that everyone seemed to tolerate. I wanted something different. So I switched.</p>
<p>Since then I have used Mac OS 10.1 through 10.9 and the switch from powerPC to Intel. And I have seen the resurgence of Apple as a contender for the home PC. I have also seen the emergence and complete dominance of computing with phones and tablets. Android, iOS, windows mobile and the ill-fated web OS and Blackberry. All this time I would call myself a computer enthusiast. Just smart enough to become the family tech guy but not smart enough to make it a career. Maybe a technology enthusiast with a minor in computers. Anyhow, it all led to a slow re-acquaintance with programming.</p>
<p>You notice after a while, the closer you are to technology, the more you encounter programming. Often it is disguised as something simple. Often it’s called “automation steps” or “scripts” or “macros”. Even formulas in Excel are a form of programming (take this number, multiply by the number to the left and add the number above… do this for every row). These days you find it in web applications (IFTTT comes to mind) and other apps (Hazel, for example). I never felt intimidated by the notion of programming, but it never felt like I was <em>really</em> programming (as I think of it). I always thought of programming as something closer to mathematics or data manipulation. Solving esoteric problems or crunching numbers. Of course it is a whole lot more than that. In it’s entirety, programming (developing software) is at the heart of <em>everything</em> we experience with technology. It is the great enabler.</p>
<h2 id="the-courtship">The Courtship</h2>
<p>And so I found myself lured by the siren call of programming. This time that world was much different than the one I left in 1986. Sure, compilers are still around. Even Pascal is still around. However, so are dozens of new, faster, easier, more powerful languages that make the programming experience much less frustrating and much more enjoyable.</p>
<p>So where does one even begin? Why not use your favorite internet search engine (a powerful set of programs by the way) and ask that very question? I didn’t, but if I do it today I would find the same resources I still use. Turns out, millions of people ask the very same question and there are thousands (probably millions) who are ready to answer or at least point you in the right direction. Welcome to the collective intelligence of the internet!</p>
<p>The top hits of a search on [Google.com] include an online course called “Getting Started with Programming”, an article titled “What’s the Best Programming Language for a Beginner?” and a YouTube video titled “Beginning Programming - Tutorial 1 Introduction”. And there are 10,000 more search results! As you can guess, it’s a hot topic and the internet is a perfect place to start.</p>
<p>Like I said earlier, I didn’t begin this way. I approached it in a slightly more indirect way. As I mentioned, I switched to Mac OS in 2001. When you make that switch, you can’t help but notice the complete difference there is between the Windows world and the Unix world. Since Mac OS X is really a fancy layer on top of a Unix operating system (just as Windows is or was a fancy layer on top of DOS) you must relearn some basic computer skills. For those who can find a command prompt on Windows and run a few basic commands (the cmd prompt and the DOS shell), there is a parallel experience on the Mac but in a new language (the terminal and bash). When I first encountered it, it felt like driving on the left side of the road in the UK for the first time. The same, but different.</p>
<p>Along with a new operating system came new system commands, a new file system, and new toys. Preinstalled on a Mac are things like Apple Script and Xcode. Apple Script is the friendly looking scripting language that allows one to automate nearly anything on a Mac. Only, it isn’t very friendly and can’t (easily) do the things I imagine a <em>real</em> program should do. But to be fair, I haven’t given it much of a chance yet. Maybe someday. Xcode is the intimidating developer application that gives any Mac owner the ability to create any program they can imagine - as long as they learn the lingua franca of the Mac world: Objective-C. Yikes! Have you seen what that looks like?</p>
<p>However, hidden among the many goodies of the Mac system are a couple of other pre-installed programming languages. And I’m not talking about BASH which is the default terminal shell environment (similar to the command prompt in Windows). Bash is itself a scriptable language (and a pretty powerful one too but focused mainly on system level things). No, I’m talking about Python and Ruby. Two relatively young, dynamic programming languages that come preinstalled and ready to run with just a one word command: “python” or “irb” ( the “irb” comes from “interactive ruby” and ruby files usually end with .rb).</p>
<p>I was vaguely aware of the dozens of newer programming languages being used by those magical “programmers”. I knew of C, C\++, Java, Perl, PHP, Lisp, Javascript, Python and Ruby to name a few. But I couldn’t tell one from another and I surely couldn’t understand their differences. I was aware of the popular concept of object oriented programming (OOP) but couldn’t describe it in any meaningful way. Still, the attraction was there for me. Right under my fingers was a tool I could learn that could let me do magical things! <em>Real</em> programming languages. How hard could it be?</p>
<p>Pretty hard. That’s how hard.</p>
<h2 id="the-wedding">The Wedding</h2>
<p>Most honest programming teachers will tell you up front: learning to program is hard. It is a new skill much like learning a new language. It takes concentration and commitment. It takes practice and study. It covers many disciplines such as mathematics and logic. It requires attention to detail and it takes a willingness to ask questions and search for answers. But none of this should scare you! Every honest programmer will also tell you: it was hard for them when they started too. And the barrier to learning is lower and lower every year.</p>
<p>So where did I begin? I began with Python. And Ruby. But mostly Python. And since I was curious as to which was the better one to start with, I read all the “Python vs. Ruby - which is better?” and “Compiled vs. Interpreted - which is better?” and “Learn C first before you learn another language” and “Java gets you more jobs” … blah blah blah blah… blah. As entertaining as all that is, it really isn’t helpful when starting out. After a while, you realize that every programming language has its strengths and weaknesses and no language is perfect for every task. But some languages are easier to learn than others, especially when you’re just a beginner. Python is one of those languages. Easy to grasp the basics and flexible enough to be forgiving. Many will argue that Ruby is better, or that you should start with a real language like C or Java. It comes down to a personal choice - which path will help you learn the basics in a way that makes sense to you. For me it was Python. And I see it is becoming the language of choice for beginning computer science courses and other computation oriented fields. So I think others can recognize its merits too.</p>
<p>In short: Python it was. I started the usual way: with a tutorial from the main site [python.org]. It does what many tutorials do. It starts with some basic math to show you how it calculates things. Then it introduces variables, functions, loops, branches… and away you go. But where exactly are you going? And why? There is always a point where you lose the purpose and the meaning of what you are shown. What is this used for? Why should I do this? Some of those questions can be answered in another forum. I found that out when I took an online course called CS 101 from [Udacity.com]. This course covered some of my why questions and introduced some good techniques for how to approach programming challenges. And it used Python as its language. Yeah! Things began to make more sense. Concepts began to click. When I finished that course I felt I could begin to program for real. I was hooked. And it was just the beginning.</p>
<p>Shortly after that class I took a few more similar ones, more practice with the language, more problem solving skills. It’s all a form of mental exercise - and it feels like my brain is the muscle getting a workout. I even branched out into some other areas such as statistics, finance and differential equations. All of those were now accessible to me with my basic programming skills. And I freely admit that <em>basic</em> is the best word to describe my skills.</p>
<p>In the mean time I have discovered a new language that has challenged my idea of programming. Haskell. Known as an “academic” language based on mathematics and set theory, this language forces me to approach programming in an entirely different way than I would with Python. The main difference is that Python (an imperative language) requires me to describe <em>how</em> to solve a problem, step by step. Haskell (a functional language) requires me to describe <em>what</em> a solution looks like without having to describe <em>how</em> to get it. It is a completely different way of approaching a problem and it forces me to think in a “new” way.</p>
<p>A language like Haskell appeals to mathematicians (I’m told) because its code looks like mathematical equations. It appeals to many programmers (I’m told) because of its elegant, minimal language and its pure, functional nature. It also has a strong type system that helps one to understand what’s going on in a program. I’ll refer to other resources ([learnyouahaskell.com]) to explain this better than I can. I can only say that it appeals to me because it’s a different way to think about programming and I’m enough of a novice not to harbor any prejudice. Finally, I must also admit that if I describe my Python skills as basic, my Haskell skills would qualify as beginner. Still, it’s so <em>interesting</em><sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>.</p>
<p>So, all that sounds wonderful but what good is it really? Here’s an example: I am a novice investor who likes to track my investment performance and investigate better methods of investing. Although I follow a “buy and hold” strategy and only think in the long term, I do like to play around with various theories centered around optimum portfolios and efficient investing. This led me to theories on minimum variance portfolios and capital asset pricing models. So I took a course in computational investing so I could see the methods explained. The course relied heavily on Excel and a little R (a mostly statistics oriented language). I could follow the theory and the methods with no trouble. But it was rather tedious to work inside a spreadsheet for all the heavy calculations involved.</p>
<p>For example, the first few steps involve downloading some price histories of a few stocks, pasting them into a spreadsheet, reordering the prices, calculating returns on the stock and finally calculating the mean and standard deviation of the returns. If you have to do that for more than a few stocks, and for more than a few years worth of data, it gets very tedious and error prone. The next steps include creating a covariance matrix for all the stocks and finally setting up a Solver scenario to find a maximum return for a minimum variance. Have you set up matrix formulas in Excel? (Hint: they can be tricky) This little project alone takes a few hours to set up and run. And if you want to change any of the inputs (like time period, which stocks to include, etc.) it takes almost as long to reset the spreadsheets as it did to set it up in the first place.</p>
<p>So I decided to try my hand at programming a better solution. With my simple program I am able to input a start and stop date and a list of stocks (or whatever thing you want prices for). The program goes to the web, downloads all the prices you require, and performs all the calculations required to return the same answer as the “manual” Excel method. In seconds. As many times as you want. With as many different inputs as you want. Complete with publication quality graphs!</p>
<h2 id="happily-ever-after">Happily Ever After?</h2>
<p>And what else do I learn after an exercise like that? I get to (re)learn about matrices, statistical variance and covariance, maximize/minimize numerical methods and Lagrange multipliers. That’s just one little project! And that’s not including the new experiences with python’s powerful packages such as numpy, scipy, pandas and matplotlib (heavy duty number crunching and plotting packages).</p>
<p>After an exercise like that, I look around and see what applications are for sale in the app stores that may do something similar. Nothing that I can find. I even looked for finance apps that could calculate rates of return for investments. Again, nothing that I can find. The closest thing I can find is Quicken from Intuit. Way more than I need and it doesn’t do what I would like anyway<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>.</p>
<p>So there’s an opportunity to create something of value for me to use - and maybe sell someday to others. Once the basic steps are done and tested, it only remains to build an interface that anyone can use and see clear results. What kind of results? How about: Using the last five years of data and a list of stocks and bonds, if I pick ten stocks then what portion should I allocate to each to give me the best return with the lowest risk? Or, which combination of eight stocks and bonds gives me the best return with the lowest risk? How about using only two years of data? What if I only want four stocks? Or, given my investment history, what is my internal rate of return? (Analogous to your average annual return) And how does that compare to the overall market? Doesn’t that sound interesting?</p>
<p>A project like that is more in the realm of a developer rather than a just a programmer. There are a whole new set of skills to learn to be a developer. Creating data structures, databases, application interfaces, testing and deployment just to name a few. See where this leads? It all started with curiosity about programming and now I’m talking about making an app for sale in the app store. And that’s what is so great about a hobby like this one. It is so powerful. Little by little, the tech around me looks less magical and more attainable, understandable.</p>
<p>Yes, I’m hooked.</p>
<h2 id="update--2019">Update (2019)</h2>
<p>Today I&rsquo;m using macOS 10.14 on a 13-inch MacBook Pro. I use a dozen or so Windows apps at work (on a Windows 10 desktop rig alongside my personal Mac) and a dozen web services of various types. I also use an iPhone X and have an iPad Pro (first gen) in my bag.</p>
<p>My latest interests (as of June this year) include machine learning, Racket, typography, and EMACS.</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>Today (2019) I&rsquo;m about 1/3 the way through <em>Haskell Programming from First Principles</em>. I still rate myself a Haskell beginner.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>Today (2019) I use Banktivity which does everything I need but is still a bit clunky and bloated. I even dabbled in ledger and beancount&mdash;but they require a <em>lot</em> of care and attention. To much for me right now.&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

</div>

        </div>
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/foundation.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
<script>
  hljs.highlightAll();
</script>


<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>


<script src="https://unpkg.com/feather-icons"></script>
<script>
  feather.replace()
</script>

<div id="nav-border" class="container">
    
    <div class="nav-outer">
        <div class="nav-inner">
            
                
                    
                        <a class="internal" hyphens="none" href="/">
                            
                            Home
                        </a>
                    
                
                    
                        <a class="internal" hyphens="none" href="/blog">
                            
                            Blog
                        </a>
                    
                
                    
                        <a class="internal" hyphens="none" href="/about">
                            
                            About
                        </a>
                    
                
                    
                
            
        </div>
    </div>
    
</div>

</body>
</html>
